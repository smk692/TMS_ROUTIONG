#!/usr/bin/env python3
"""
Í≤ΩÎ°ú ÏµúÏ†ÅÌôî Î∂ÑÏÑùÍ∏∞

Í≤ΩÎ°ú Ï§ëÎ≥µ, Ìö®Ïú®ÏÑ±, ÏÑ±Îä• ÏßÄÌëúÎ•º Ï¢ÖÌï©Ï†ÅÏúºÎ°ú Î∂ÑÏÑù
src/analysis Î™®ÎìàÎ°ú ÌÜµÌï©Îê®
"""

import json
import math
import numpy as np
from pathlib import Path
from collections import defaultdict
from typing import Dict, List, Tuple, Optional
import matplotlib.pyplot as plt

class RouteAnalyzer:
    """Í≤ΩÎ°ú ÏµúÏ†ÅÌôî Ï¢ÖÌï© Î∂ÑÏÑùÍ∏∞"""
    
    def __init__(self, data: Dict = None, data_file: str = None):
        """
        Ï¥àÍ∏∞Ìôî
        Args:
            data: ÏßÅÏ†ë Ï†ÑÎã¨Îêú Îç∞Ïù¥ÌÑ∞ ÎîïÏÖîÎÑàÎ¶¨
            data_file: Îç∞Ïù¥ÌÑ∞ ÌååÏùº Í≤ΩÎ°ú (data ÏóÜÏùÑ ÎïåÎßå ÏÇ¨Ïö©)
        """
        if data is not None:
            self.data = data
        else:
            # Í∏∞Î≥∏ ÌååÏùº Í≤ΩÎ°ú ÏÑ§Ï†ï
            if data_file is None:
                data_file = "../../data/extracted_coordinates.json"
            
            self.data = self._load_data(data_file)
        
        # Î∂ÑÏÑù Í≤∞Í≥º Ï†ÄÏû•
        self.analysis_results = {}
    
    def _load_data(self, file_path: str) -> Optional[Dict]:
        """Îç∞Ïù¥ÌÑ∞ ÌååÏùº Î°úÎìú"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"‚ö†Ô∏è ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: {file_path}")
            return None
        except Exception as e:
            print(f"‚ùå ÌååÏùº Î°úÎìú Ïò§Î•ò: {e}")
            return None
    
    def analyze_route_optimization(self) -> Dict:
        """Í≤ΩÎ°ú ÏµúÏ†ÅÌôî Ï¢ÖÌï© Î∂ÑÏÑù"""
        if not self.data:
            print("‚ùå Î∂ÑÏÑùÌï† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.")
            return {}
        
        print("üîç Í≤ΩÎ°ú ÏµúÏ†ÅÌôî Ï¢ÖÌï© Î∂ÑÏÑù ÏãúÏûë...")
        
        # Í∏∞Î≥∏ ÌÜµÍ≥Ñ Î∂ÑÏÑù
        basic_stats = self._analyze_basic_statistics()
        
        # Í≤ΩÎ°ú Ï§ëÎ≥µ Î∂ÑÏÑù
        overlap_analysis = self._analyze_route_overlaps()
        
        # Ìö®Ïú®ÏÑ± ÏßÄÌëú Î∂ÑÏÑù
        efficiency_analysis = self._analyze_efficiency_metrics()
        
        # TCÎ≥Ñ ÏÑ±Îä• Î∂ÑÏÑù
        tc_analysis = self._analyze_tc_performance()
        
        # Ï∞®ÎüâÎ≥Ñ ÏÑ±Îä• Î∂ÑÏÑù
        vehicle_analysis = self._analyze_vehicle_performance()
        
        # ÏßÄÏó≠Î≥Ñ Î∂ÑÌè¨ Î∂ÑÏÑù
        distribution_analysis = self._analyze_geographical_distribution()
        
        # Í≤∞Í≥º ÌÜµÌï©
        self.analysis_results = {
            'basic_stats': basic_stats,
            'overlap_analysis': overlap_analysis,
            'efficiency_analysis': efficiency_analysis,
            'tc_analysis': tc_analysis,
            'vehicle_analysis': vehicle_analysis,
            'distribution_analysis': distribution_analysis,
            'recommendations': self._generate_recommendations()
        }
        
        return self.analysis_results
    
    def _analyze_basic_statistics(self) -> Dict:
        """Í∏∞Î≥∏ ÌÜµÍ≥Ñ Î∂ÑÏÑù"""
        stats = self.data.get('stats', {})
        routes = self.data.get('routes', {})
        
        return {
            'total_vehicles': len(routes),
            'total_points': stats.get('total_points', 0),
            'total_distance': stats.get('total_distance', 0),
            'total_time': stats.get('total_time', 0),
            'avg_distance_per_vehicle': stats.get('total_distance', 0) / max(len(routes), 1),
            'avg_points_per_vehicle': stats.get('total_points', 0) / max(len(routes), 1),
            'avg_time_per_vehicle': stats.get('total_time', 0) / max(len(routes), 1)
        }
    
    def _analyze_route_overlaps(self) -> Dict:
        """Í≤ΩÎ°ú Ï§ëÎ≥µ Î∂ÑÏÑù"""
        routes = self.data.get('routes', {})
        
        # TCÎ≥Ñ Í∑∏Î£πÌôî
        tc_routes = defaultdict(list)
        for vehicle_id, route_data in routes.items():
            tc_id = route_data.get('tc_id', 'unknown')
            tc_routes[tc_id].append((vehicle_id, route_data))
        
        total_overlaps = 0
        tc_overlap_details = {}
        
        for tc_id, tc_route_list in tc_routes.items():
            if len(tc_route_list) < 2:
                tc_overlap_details[tc_id] = {'overlaps': 0, 'overlap_pairs': []}
                continue
            
            tc_overlaps = 0
            overlap_pairs = []
            
            for i in range(len(tc_route_list)):
                for j in range(i + 1, len(tc_route_list)):
                    vehicle1_id, route1 = tc_route_list[i]
                    vehicle2_id, route2 = tc_route_list[j]
                    
                    # Í≤ΩÎ°ú Ï§ëÎ≥µ Í≥ÑÏÇ∞
                    overlap_count = self._calculate_route_overlap(route1, route2)
                    
                    if overlap_count > 0:
                        tc_overlaps += overlap_count
                        total_overlaps += overlap_count
                        overlap_pairs.append({
                            'vehicle1': vehicle1_id,
                            'vehicle2': vehicle2_id,
                            'overlap_count': overlap_count
                        })
            
            tc_overlap_details[tc_id] = {
                'overlaps': tc_overlaps,
                'overlap_pairs': overlap_pairs
            }
        
        return {
            'total_overlaps': total_overlaps,
            'tc_overlap_details': tc_overlap_details,
            'overlap_rate': self._calculate_overlap_rate(total_overlaps, len(routes))
        }
    
    def _calculate_route_overlap(self, route1: Dict, route2: Dict) -> int:
        """Îëê Í≤ΩÎ°ú Í∞Ñ Ï§ëÎ≥µ Î∞∞ÏÜ°ÏßÄ Í≥ÑÏÇ∞"""
        route1_points = set()
        route2_points = set()
        
        # Í≤ΩÎ°ú 1Ïùò Î∞∞ÏÜ°ÏßÄ ÏàòÏßë
        for point in route1.get('route', []):
            if point.get('type') == 'delivery':
                route1_points.add((point.get('lat'), point.get('lng')))
        
        # Í≤ΩÎ°ú 2Ïùò Î∞∞ÏÜ°ÏßÄ ÏàòÏßë
        for point in route2.get('route', []):
            if point.get('type') == 'delivery':
                route2_points.add((point.get('lat'), point.get('lng')))
        
        # Ï§ëÎ≥µ Î∞∞ÏÜ°ÏßÄ Í≥ÑÏÇ∞
        return len(route1_points.intersection(route2_points))
    
    def _calculate_overlap_rate(self, total_overlaps: int, total_vehicles: int) -> float:
        """Ï§ëÎ≥µÎ•† Í≥ÑÏÇ∞"""
        if total_vehicles <= 1:
            return 0.0
        
        max_possible_pairs = total_vehicles * (total_vehicles - 1) / 2
        return (total_overlaps / max_possible_pairs) * 100 if max_possible_pairs > 0 else 0.0
    
    def _analyze_efficiency_metrics(self) -> Dict:
        """Ìö®Ïú®ÏÑ± ÏßÄÌëú Î∂ÑÏÑù"""
        routes = self.data.get('routes', {})
        stats = self.data.get('stats', {})
        
        # Ï∞®ÎüâÎ≥Ñ Ìö®Ïú®ÏÑ± Í≥ÑÏÇ∞
        vehicle_efficiencies = []
        for vehicle_id, route_data in routes.items():
            delivery_count = len([p for p in route_data.get('route', []) if p.get('type') == 'delivery'])
            distance = route_data.get('total_distance', 0)
            time = route_data.get('total_time', 0)
            
            efficiency = {
                'vehicle_id': vehicle_id,
                'delivery_count': delivery_count,
                'distance': distance,
                'time': time,
                'distance_per_delivery': distance / max(delivery_count, 1),
                'time_per_delivery': time / max(delivery_count, 1)
            }
            vehicle_efficiencies.append(efficiency)
        
        # ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
        distances = [v['distance'] for v in vehicle_efficiencies]
        times = [v['time'] for v in vehicle_efficiencies]
        deliveries = [v['delivery_count'] for v in vehicle_efficiencies]
        
        return {
            'vehicle_efficiencies': vehicle_efficiencies,
            'distance_stats': {
                'mean': np.mean(distances) if distances else 0,
                'std': np.std(distances) if distances else 0,
                'min': min(distances) if distances else 0,
                'max': max(distances) if distances else 0
            },
            'time_stats': {
                'mean': np.mean(times) if times else 0,
                'std': np.std(times) if times else 0,
                'min': min(times) if times else 0,
                'max': max(times) if times else 0
            },
            'delivery_stats': {
                'mean': np.mean(deliveries) if deliveries else 0,
                'std': np.std(deliveries) if deliveries else 0,
                'min': min(deliveries) if deliveries else 0,
                'max': max(deliveries) if deliveries else 0
            }
        }
    
    def _analyze_tc_performance(self) -> Dict:
        """TCÎ≥Ñ ÏÑ±Îä• Î∂ÑÏÑù"""
        routes = self.data.get('routes', {})
        
        tc_performance = defaultdict(lambda: {
            'vehicles': 0,
            'total_points': 0,
            'total_distance': 0,
            'total_time': 0
        })
        
        for vehicle_id, route_data in routes.items():
            tc_id = route_data.get('tc_id', 'unknown')
            delivery_count = len([p for p in route_data.get('route', []) if p.get('type') == 'delivery'])
            
            tc_performance[tc_id]['vehicles'] += 1
            tc_performance[tc_id]['total_points'] += delivery_count
            tc_performance[tc_id]['total_distance'] += route_data.get('total_distance', 0)
            tc_performance[tc_id]['total_time'] += route_data.get('total_time', 0)
        
        # ÌèâÍ∑† Í≥ÑÏÇ∞
        for tc_id, perf in tc_performance.items():
            vehicles = perf['vehicles']
            if vehicles > 0:
                perf['avg_distance_per_vehicle'] = perf['total_distance'] / vehicles
                perf['avg_points_per_vehicle'] = perf['total_points'] / vehicles
                perf['avg_time_per_vehicle'] = perf['total_time'] / vehicles
            else:
                perf['avg_distance_per_vehicle'] = 0
                perf['avg_points_per_vehicle'] = 0
                perf['avg_time_per_vehicle'] = 0
        
        return dict(tc_performance)
    
    def _analyze_vehicle_performance(self) -> Dict:
        """Ï∞®ÎüâÎ≥Ñ ÏÑ±Îä• Î∂ÑÏÑù"""
        routes = self.data.get('routes', {})
        
        vehicle_performance = []
        for vehicle_id, route_data in routes.items():
            delivery_count = len([p for p in route_data.get('route', []) if p.get('type') == 'delivery'])
            distance = route_data.get('total_distance', 0)
            time = route_data.get('total_time', 0)
            
            performance = {
                'vehicle_id': vehicle_id,
                'tc_id': route_data.get('tc_id', 'unknown'),
                'delivery_count': delivery_count,
                'distance': distance,
                'time': time,
                'efficiency_score': self._calculate_efficiency_score(delivery_count, distance, time)
            }
            vehicle_performance.append(performance)
        
        # ÏÑ±Îä• ÏàúÏúÑ Í≥ÑÏÇ∞
        vehicle_performance.sort(key=lambda x: x['efficiency_score'], reverse=True)
        
        return {
            'vehicle_rankings': vehicle_performance,
            'top_performers': vehicle_performance[:5],
            'bottom_performers': vehicle_performance[-5:] if len(vehicle_performance) >= 5 else []
        }
    
    def _calculate_efficiency_score(self, delivery_count: int, distance: float, time: float) -> float:
        """Ìö®Ïú®ÏÑ± Ï†êÏàò Í≥ÑÏÇ∞"""
        if distance == 0 or time == 0:
            return 0.0
        
        # Î∞∞ÏÜ°ÏßÄ Ïàò ÎåÄÎπÑ Í±∞Î¶¨ÏôÄ ÏãúÍ∞ÑÏùò Ìö®Ïú®ÏÑ±
        distance_efficiency = delivery_count / distance if distance > 0 else 0
        time_efficiency = delivery_count / time if time > 0 else 0
        
        # Í∞ÄÏ§ë ÌèâÍ∑† (Í±∞Î¶¨ 60%, ÏãúÍ∞Ñ 40%)
        return (distance_efficiency * 0.6 + time_efficiency * 0.4) * 100
    
    def _analyze_geographical_distribution(self) -> Dict:
        """ÏßÄÏó≠Î≥Ñ Î∂ÑÌè¨ Î∂ÑÏÑù"""
        routes = self.data.get('routes', {})
        
        # Î∞∞ÏÜ°ÏßÄ Ï¢åÌëú ÏàòÏßë
        all_coordinates = []
        tc_coordinates = defaultdict(list)
        
        for vehicle_id, route_data in routes.items():
            tc_id = route_data.get('tc_id', 'unknown')
            
            for point in route_data.get('route', []):
                if point.get('type') == 'delivery':
                    coord = (point.get('lat'), point.get('lng'))
                    all_coordinates.append(coord)
                    tc_coordinates[tc_id].append(coord)
        
        # Î∂ÑÌè¨ ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
        distribution_stats = {}
        
        if all_coordinates:
            lats = [coord[0] for coord in all_coordinates]
            lngs = [coord[1] for coord in all_coordinates]
            
            distribution_stats['overall'] = {
                'center_lat': np.mean(lats),
                'center_lng': np.mean(lngs),
                'lat_range': max(lats) - min(lats),
                'lng_range': max(lngs) - min(lngs),
                'spread_score': np.std(lats) + np.std(lngs)
            }
        
        # TCÎ≥Ñ Î∂ÑÌè¨
        for tc_id, coords in tc_coordinates.items():
            if coords:
                lats = [coord[0] for coord in coords]
                lngs = [coord[1] for coord in coords]
                
                distribution_stats[tc_id] = {
                    'center_lat': np.mean(lats),
                    'center_lng': np.mean(lngs),
                    'lat_range': max(lats) - min(lats),
                    'lng_range': max(lngs) - min(lngs),
                    'spread_score': np.std(lats) + np.std(lngs)
                }
        
        return distribution_stats
    
    def _generate_recommendations(self) -> List[str]:
        """Í∞úÏÑ† Í∂åÏû•ÏÇ¨Ìï≠ ÏÉùÏÑ±"""
        recommendations = []
        
        if not self.analysis_results:
            return recommendations
        
        # Ï§ëÎ≥µ Î∂ÑÏÑù Í∏∞Î∞ò Í∂åÏû•ÏÇ¨Ìï≠
        overlap_analysis = self.analysis_results.get('overlap_analysis', {})
        total_overlaps = overlap_analysis.get('total_overlaps', 0)
        
        if total_overlaps > 50:
            recommendations.append("üî• ÎÜíÏùÄ Í≤ΩÎ°ú Ï§ëÎ≥µ Í∞êÏßÄ: Voronoi Îã§Ïù¥Ïñ¥Í∑∏Îû® Í∏∞Î∞ò ÏµúÏ†ÅÌôî Ï†ÅÏö© Í∂åÏû•")
        elif total_overlaps > 20:
            recommendations.append("‚ö†Ô∏è Ï§ëÍ∞Ñ ÏàòÏ§Ä Í≤ΩÎ°ú Ï§ëÎ≥µ: ÌÅ¥Îü¨Ïä§ÌÑ∞ÎßÅ Í∏∞Î∞ò ÏµúÏ†ÅÌôî Í≤ÄÌÜ† Í∂åÏû•")
        
        # Ìö®Ïú®ÏÑ± Î∂ÑÏÑù Í∏∞Î∞ò Í∂åÏû•ÏÇ¨Ìï≠
        efficiency_analysis = self.analysis_results.get('efficiency_analysis', {})
        distance_std = efficiency_analysis.get('distance_stats', {}).get('std', 0)
        
        if distance_std > 50:
            recommendations.append("üìä Ï∞®Îüâ Í∞Ñ Í±∞Î¶¨ Ìé∏Ï∞® ÌÅº: Î∞∞ÏÜ°ÏßÄ Ïû¨Î∂ÑÎ∞∞ Í≤ÄÌÜ† ÌïÑÏöî")
        
        # TCÎ≥Ñ ÏÑ±Îä• Í∏∞Î∞ò Í∂åÏû•ÏÇ¨Ìï≠
        tc_analysis = self.analysis_results.get('tc_analysis', {})
        tc_distances = [tc_data.get('avg_distance_per_vehicle', 0) for tc_data in tc_analysis.values()]
        
        if tc_distances and max(tc_distances) / min(tc_distances) > 2:
            recommendations.append("üè¢ TC Í∞Ñ Î∂ÄÌïò Î∂àÍ∑†Ìòï: Ï∞®Îüâ Ïû¨Î∞∞Ïπò ÎòêÎäî ÏòÅÏó≠ Ï°∞Ï†ï Í∂åÏû•")
        
        if not recommendations:
            recommendations.append("‚úÖ ÌòÑÏû¨ ÏµúÏ†ÅÌôî ÏÉÅÌÉú ÏñëÌò∏: Ï†ïÍ∏∞Ï†ÅÏù∏ Î™®ÎãàÌÑ∞ÎßÅ Ïú†ÏßÄ")
        
        return recommendations
    
    def print_analysis_report(self):
        """Î∂ÑÏÑù Í≤∞Í≥º Î¶¨Ìè¨Ìä∏ Ï∂úÎ†•"""
        if not self.analysis_results:
            self.analyze_route_optimization()
        
        print("\n" + "="*60)
        print("üìä Í≤ΩÎ°ú ÏµúÏ†ÅÌôî Ï¢ÖÌï© Î∂ÑÏÑù Î¶¨Ìè¨Ìä∏")
        print("="*60)
        
        # Í∏∞Î≥∏ ÌÜµÍ≥Ñ
        basic_stats = self.analysis_results.get('basic_stats', {})
        print(f"\nüìà Í∏∞Î≥∏ ÌÜµÍ≥Ñ:")
        print(f"   Ï¥ù Ï∞®Îüâ: {basic_stats.get('total_vehicles', 0)}ÎåÄ")
        print(f"   Ï¥ù Î∞∞ÏÜ°ÏßÄ: {basic_stats.get('total_points', 0)}Í∞ú")
        print(f"   Ï¥ù Í±∞Î¶¨: {basic_stats.get('total_distance', 0):.1f}km")
        print(f"   Ï¥ù ÏãúÍ∞Ñ: {basic_stats.get('total_time', 0):.0f}Î∂Ñ")
        print(f"   Ï∞®ÎüâÎãπ ÌèâÍ∑† Í±∞Î¶¨: {basic_stats.get('avg_distance_per_vehicle', 0):.1f}km")
        print(f"   Ï∞®ÎüâÎãπ ÌèâÍ∑† Î∞∞ÏÜ°ÏßÄ: {basic_stats.get('avg_points_per_vehicle', 0):.1f}Í∞ú")
        
        # Ï§ëÎ≥µ Î∂ÑÏÑù
        overlap_analysis = self.analysis_results.get('overlap_analysis', {})
        print(f"\nüîÑ Í≤ΩÎ°ú Ï§ëÎ≥µ Î∂ÑÏÑù:")
        print(f"   Ï¥ù Ï§ëÎ≥µ Í±¥Ïàò: {overlap_analysis.get('total_overlaps', 0)}Í±¥")
        print(f"   Ï§ëÎ≥µÎ•†: {overlap_analysis.get('overlap_rate', 0):.1f}%")
        
        # TCÎ≥Ñ Ï§ëÎ≥µ ÏÉÅÏÑ∏
        tc_overlap_details = overlap_analysis.get('tc_overlap_details', {})
        for tc_id, details in tc_overlap_details.items():
            if details['overlaps'] > 0:
                print(f"   {tc_id}: {details['overlaps']}Í±¥ Ï§ëÎ≥µ")
        
        # Ìö®Ïú®ÏÑ± Î∂ÑÏÑù
        efficiency_analysis = self.analysis_results.get('efficiency_analysis', {})
        distance_stats = efficiency_analysis.get('distance_stats', {})
        print(f"\n‚ö° Ìö®Ïú®ÏÑ± Î∂ÑÏÑù:")
        print(f"   Í±∞Î¶¨ Ìé∏Ï∞®: {distance_stats.get('std', 0):.1f}km")
        print(f"   ÏµúÎåÄ Í±∞Î¶¨: {distance_stats.get('max', 0):.1f}km")
        print(f"   ÏµúÏÜå Í±∞Î¶¨: {distance_stats.get('min', 0):.1f}km")
        
        # Í∂åÏû•ÏÇ¨Ìï≠
        recommendations = self.analysis_results.get('recommendations', [])
        print(f"\nüí° Í∞úÏÑ† Í∂åÏû•ÏÇ¨Ìï≠:")
        for i, rec in enumerate(recommendations, 1):
            print(f"   {i}. {rec}")
        
        print("="*60)


def analyze_route_optimization(data: Dict = None, data_file: str = None) -> Dict:
    """
    Í≤ΩÎ°ú ÏµúÏ†ÅÌôî Ï¢ÖÌï© Î∂ÑÏÑù (Ïô∏Î∂Ä Ìò∏Ï∂úÏö© Ìï®Ïàò)
    
    Args:
        data: ÏßÅÏ†ë Ï†ÑÎã¨Îêú Îç∞Ïù¥ÌÑ∞ ÎîïÏÖîÎÑàÎ¶¨
        data_file: Îç∞Ïù¥ÌÑ∞ ÌååÏùº Í≤ΩÎ°ú
    
    Returns:
        Î∂ÑÏÑù Í≤∞Í≥º ÎîïÏÖîÎÑàÎ¶¨
    """
    analyzer = RouteAnalyzer(data, data_file)
    results = analyzer.analyze_route_optimization()
    analyzer.print_analysis_report()
    return results


if __name__ == "__main__":
    # ÎèÖÎ¶Ω Ïã§Ìñâ Ïãú Í∏∞Î≥∏ Î∂ÑÏÑù ÏàòÌñâ
    analyzer = RouteAnalyzer()
    analyzer.analyze_route_optimization()
    analyzer.print_analysis_report() 