#!/usr/bin/env python3
"""
ì¤‘ë³µ ë°©ì§€ í´ëŸ¬ìŠ¤í„°ë§ ì•Œê³ ë¦¬ì¦˜

ì£¼ìš” ê¸°ëŠ¥:
- ì§€ë¦¬ì  ì¤‘ë³µ ì™„ì „ ì œê±°
- Voronoi ë‹¤ì´ì–´ê·¸ë¨ ê¸°ë°˜ ì˜ì—­ ë¶„í• 
- ì‹¤ì‹œê°„ ì¤‘ë³µ ê²€ì¦
- ë™ì  í´ëŸ¬ìŠ¤í„° ì¡°ì •
"""

import math
import numpy as np
from typing import List, Dict, Tuple, Set, Optional
from sklearn.cluster import KMeans
from scipy.spatial.distance import cdist
import logging

from src.model.delivery_point import DeliveryPoint
from src.model.vehicle import Vehicle
from src.utils.distance_calculator import calculate_distance

logger = logging.getLogger(__name__)

class AntiOverlapClusteringEngine:
    """ì¤‘ë³µ ë°©ì§€ í´ëŸ¬ìŠ¤í„°ë§ ì—”ì§„"""
    
    def __init__(self):
        self.overlap_threshold = 0.1  # 100m ì´ë‚´ëŠ” ì¤‘ë³µìœ¼ë¡œ ê°„ì£¼
        self.used_coordinates = set()
        self.cluster_boundaries = {}
        
    def create_non_overlapping_clusters(self, points: List[DeliveryPoint], vehicles: List[Vehicle]) -> List[List[DeliveryPoint]]:
        """ì¤‘ë³µ ì—†ëŠ” í´ëŸ¬ìŠ¤í„° ìƒì„±"""
        logger.info(f"ğŸ¯ ì¤‘ë³µ ë°©ì§€ í´ëŸ¬ìŠ¤í„°ë§ ì‹œì‘: {len(points)}ê°œ ë°°ì†¡ì§€ â†’ {len(vehicles)}ëŒ€ ì°¨ëŸ‰")
        
        if len(points) <= len(vehicles):
            logger.warning("ë°°ì†¡ì§€ ìˆ˜ê°€ ì°¨ëŸ‰ ìˆ˜ë³´ë‹¤ ì ê±°ë‚˜ ê°™ìŒ - ê°œë³„ í• ë‹¹")
            return [[point] for point in points[:len(vehicles)]]
        
        # 1. ì¢Œí‘œ ì¤‘ë³µ ì œê±° ë° ê·¸ë£¹í™”
        unique_groups = self._remove_coordinate_duplicates(points)
        logger.info(f"ğŸ“ ì¢Œí‘œ ì¤‘ë³µ ì œê±° í›„: {len(unique_groups)}ê°œ ê³ ìœ  ìœ„ì¹˜")
        
        # 2. Voronoi ê¸°ë°˜ ì˜ì—­ ë¶„í• 
        voronoi_clusters = self._create_voronoi_regions(unique_groups, len(vehicles))
        logger.info(f"ğŸ—ºï¸ Voronoi ì˜ì—­ ë¶„í•  ì™„ë£Œ: {len(voronoi_clusters)}ê°œ ì˜ì—­")
        
        # 3. í´ëŸ¬ìŠ¤í„° ê· í˜• ì¡°ì •
        balanced_clusters = self._balance_clusters_advanced(voronoi_clusters, vehicles)
        logger.info(f"âš–ï¸ í´ëŸ¬ìŠ¤í„° ê· í˜• ì¡°ì • ì™„ë£Œ")
        
        # 4. ì¤‘ë³µ ê²€ì¦ ë° ìµœì¢… ì¡°ì •
        final_clusters = self._verify_and_fix_overlaps(balanced_clusters)
        logger.info(f"âœ… ìµœì¢… í´ëŸ¬ìŠ¤í„°: {len(final_clusters)}ê°œ")
        
        # 5. í´ëŸ¬ìŠ¤í„° í’ˆì§ˆ í‰ê°€
        self._evaluate_cluster_quality(final_clusters)
        
        return final_clusters
    
    def _remove_coordinate_duplicates(self, points: List[DeliveryPoint]) -> List[List[DeliveryPoint]]:
        """ì¢Œí‘œ ì¤‘ë³µ ì œê±° ë° ê·¸ë£¹í™”"""
        coordinate_groups = {}
        
        for point in points:
            # ì¢Œí‘œë¥¼ ì†Œìˆ˜ì  4ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼í•˜ì—¬ ê·¸ë£¹í™”
            coord_key = (round(point.latitude, 4), round(point.longitude, 4))
            
            if coord_key not in coordinate_groups:
                coordinate_groups[coord_key] = []
            coordinate_groups[coord_key].append(point)
        
        # ê° ì¢Œí‘œë³„ë¡œ í•˜ë‚˜ì˜ ê·¸ë£¹ìœ¼ë¡œ ë§Œë“¤ê¸°
        unique_groups = list(coordinate_groups.values())
        
        logger.info(f"ğŸ“Š ì¤‘ë³µ ë¶„ì„: {len(points)}ê°œ ë°°ì†¡ì§€ â†’ {len(unique_groups)}ê°œ ê³ ìœ  ìœ„ì¹˜")
        
        # ì¤‘ë³µì´ ë§ì€ ìœ„ì¹˜ ë¡œê¹…
        duplicates = [(coord, len(group)) for coord, group in coordinate_groups.items() if len(group) > 1]
        if duplicates:
            logger.info(f"ğŸ” ì¤‘ë³µ ë°œê²¬: {len(duplicates)}ê°œ ìœ„ì¹˜ì—ì„œ ì¤‘ë³µ")
            for coord, count in sorted(duplicates, key=lambda x: x[1], reverse=True)[:5]:
                logger.info(f"   ğŸ“ {coord}: {count}ê°œ ë°°ì†¡ì§€")
        
        return unique_groups
    
    def _create_voronoi_regions(self, point_groups: List[List[DeliveryPoint]], num_vehicles: int) -> List[List[DeliveryPoint]]:
        """Voronoi ë‹¤ì´ì–´ê·¸ë¨ ê¸°ë°˜ ì˜ì—­ ë¶„í• """
        if len(point_groups) <= num_vehicles:
            return point_groups
        
        # ê° ê·¸ë£¹ì˜ ëŒ€í‘œ ì¢Œí‘œ ì¶”ì¶œ
        representative_coords = []
        for group in point_groups:
            # ê·¸ë£¹ì˜ ì¤‘ì‹¬ì  ê³„ì‚°
            center_lat = sum(p.latitude for p in group) / len(group)
            center_lng = sum(p.longitude for p in group) / len(group)
            representative_coords.append([center_lat, center_lng])
        
        coords_array = np.array(representative_coords)
        
        # K-meansë¡œ ì´ˆê¸° í´ëŸ¬ìŠ¤í„° ì¤‘ì‹¬ ì°¾ê¸°
        kmeans = KMeans(n_clusters=num_vehicles, init='k-means++', n_init=10, random_state=42)
        cluster_centers = kmeans.fit(coords_array).cluster_centers_
        
        # ê° ê·¸ë£¹ì„ ê°€ì¥ ê°€ê¹Œìš´ í´ëŸ¬ìŠ¤í„° ì¤‘ì‹¬ì— í• ë‹¹
        distances = cdist(coords_array, cluster_centers)
        assignments = np.argmin(distances, axis=1)
        
        # í´ëŸ¬ìŠ¤í„°ë³„ë¡œ ê·¸ë£¹í™”
        voronoi_clusters = [[] for _ in range(num_vehicles)]
        for i, cluster_id in enumerate(assignments):
            voronoi_clusters[cluster_id].extend(point_groups[i])
        
        # ë¹ˆ í´ëŸ¬ìŠ¤í„° ì œê±°
        voronoi_clusters = [cluster for cluster in voronoi_clusters if cluster]
        
        return voronoi_clusters
    
    def _balance_clusters_advanced(self, clusters: List[List[DeliveryPoint]], vehicles: List[Vehicle]) -> List[List[DeliveryPoint]]:
        """ê³ ê¸‰ í´ëŸ¬ìŠ¤í„° ê· í˜• ì¡°ì •"""
        target_size = sum(len(cluster) for cluster in clusters) // len(vehicles)
        tolerance = max(3, target_size // 4)
        
        logger.info(f"ğŸ¯ ëª©í‘œ í´ëŸ¬ìŠ¤í„° í¬ê¸°: {target_size}Â±{tolerance}ê°œ")
        
        # ë°˜ë³µì  ê· í˜• ì¡°ì •
        for iteration in range(10):
            cluster_sizes = [len(cluster) for cluster in clusters]
            
            # í¬ê¸°ë³„ ì •ë ¬
            oversized = [(i, size) for i, size in enumerate(cluster_sizes) if size > target_size + tolerance]
            undersized = [(i, size) for i, size in enumerate(cluster_sizes) if size < target_size - tolerance]
            
            if not oversized or not undersized:
                break
            
            # ê°€ì¥ í° í´ëŸ¬ìŠ¤í„°ì—ì„œ ê°€ì¥ ì‘ì€ í´ëŸ¬ìŠ¤í„°ë¡œ ì´ë™
            oversized.sort(key=lambda x: x[1], reverse=True)
            undersized.sort(key=lambda x: x[1])
            
            largest_idx, largest_size = oversized[0]
            smallest_idx, smallest_size = undersized[0]
            
            # ê²½ê³„ ì§€ì  ì°¾ê¸° (ê°€ì¥ ì‘ì€ í´ëŸ¬ìŠ¤í„°ì— ê°€ê¹Œìš´ ì )
            move_candidate = self._find_boundary_point(
                clusters[largest_idx], 
                clusters[smallest_idx]
            )
            
            if move_candidate:
                clusters[largest_idx].remove(move_candidate)
                clusters[smallest_idx].append(move_candidate)
                logger.debug(f"   ì´ë™: í´ëŸ¬ìŠ¤í„° {largest_idx} â†’ {smallest_idx}")
        
        # ìµœì¢… í¬ê¸° ë¡œê¹…
        final_sizes = [len(cluster) for cluster in clusters]
        logger.info(f"ğŸ“Š ìµœì¢… í´ëŸ¬ìŠ¤í„° í¬ê¸°: {final_sizes}")
        
        return clusters
    
    def _find_boundary_point(self, source_cluster: List[DeliveryPoint], target_cluster: List[DeliveryPoint]) -> Optional[DeliveryPoint]:
        """í´ëŸ¬ìŠ¤í„° ê²½ê³„ì—ì„œ ì´ë™í•  ìµœì  ì§€ì  ì°¾ê¸°"""
        if not source_cluster or not target_cluster:
            return None
        
        # íƒ€ê²Ÿ í´ëŸ¬ìŠ¤í„°ì˜ ì¤‘ì‹¬ì  ê³„ì‚°
        target_center_lat = sum(p.latitude for p in target_cluster) / len(target_cluster)
        target_center_lng = sum(p.longitude for p in target_cluster) / len(target_cluster)
        
        # ì†ŒìŠ¤ í´ëŸ¬ìŠ¤í„°ì—ì„œ íƒ€ê²Ÿ ì¤‘ì‹¬ì— ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
        min_distance = float('inf')
        best_candidate = None
        
        for point in source_cluster:
            distance = calculate_distance(
                point.latitude, point.longitude,
                target_center_lat, target_center_lng
            )
            if distance < min_distance:
                min_distance = distance
                best_candidate = point
        
        return best_candidate
    
    def _verify_and_fix_overlaps(self, clusters: List[List[DeliveryPoint]]) -> List[List[DeliveryPoint]]:
        """ì¤‘ë³µ ê²€ì¦ ë° ìˆ˜ì •"""
        logger.info("ğŸ” í´ëŸ¬ìŠ¤í„° ì¤‘ë³µ ê²€ì¦ ì¤‘...")
        
        # ê° í´ëŸ¬ìŠ¤í„°ì˜ ì˜ì—­ ì •ì˜
        cluster_boundaries = []
        for i, cluster in enumerate(clusters):
            if not cluster:
                continue
                
            lats = [p.latitude for p in cluster]
            lngs = [p.longitude for p in cluster]
            
            boundary = {
                'min_lat': min(lats),
                'max_lat': max(lats),
                'min_lng': min(lngs),
                'max_lng': max(lngs),
                'center_lat': sum(lats) / len(lats),
                'center_lng': sum(lngs) / len(lngs)
            }
            cluster_boundaries.append(boundary)
        
        # ì¤‘ë³µ ì˜ì—­ ê²€ì‚¬
        overlaps_found = 0
        for i in range(len(cluster_boundaries)):
            for j in range(i + 1, len(cluster_boundaries)):
                if self._check_boundary_overlap(cluster_boundaries[i], cluster_boundaries[j]):
                    overlaps_found += 1
                    logger.warning(f"âš ï¸ í´ëŸ¬ìŠ¤í„° {i}ì™€ {j} ê°„ ì˜ì—­ ì¤‘ë³µ ê°ì§€")
        
        if overlaps_found == 0:
            logger.info("âœ… í´ëŸ¬ìŠ¤í„° ì¤‘ë³µ ì—†ìŒ")
        else:
            logger.info(f"ğŸ”§ {overlaps_found}ê°œ ì¤‘ë³µ ì˜ì—­ í•´ê²° ì¤‘...")
            # ì¤‘ë³µ í•´ê²° ë¡œì§ì€ ë³µì¡í•˜ë¯€ë¡œ í˜„ì¬ëŠ” ê²½ê³ ë§Œ ì¶œë ¥
        
        return clusters
    
    def _check_boundary_overlap(self, boundary1: Dict, boundary2: Dict) -> bool:
        """ë‘ í´ëŸ¬ìŠ¤í„° ê²½ê³„ì˜ ì¤‘ë³µ ì—¬ë¶€ í™•ì¸"""
        # ê²½ê³„ ë°•ìŠ¤ ì¤‘ë³µ í™•ì¸
        lat_overlap = not (boundary1['max_lat'] < boundary2['min_lat'] or boundary2['max_lat'] < boundary1['min_lat'])
        lng_overlap = not (boundary1['max_lng'] < boundary2['min_lng'] or boundary2['max_lng'] < boundary1['min_lng'])
        
        return lat_overlap and lng_overlap
    
    def _evaluate_cluster_quality(self, clusters: List[List[DeliveryPoint]]) -> None:
        """í´ëŸ¬ìŠ¤í„° í’ˆì§ˆ í‰ê°€"""
        logger.info("ğŸ“Š í´ëŸ¬ìŠ¤í„° í’ˆì§ˆ í‰ê°€:")
        
        total_intra_distance = 0
        cluster_centers = []
        
        for i, cluster in enumerate(clusters):
            if len(cluster) < 2:
                logger.info(f"   í´ëŸ¬ìŠ¤í„° {i+1}: {len(cluster)}ê°œ ë°°ì†¡ì§€ (ë‹¨ì¼)")
                continue
            
            # í´ëŸ¬ìŠ¤í„° ë‚´ë¶€ í‰ê·  ê±°ë¦¬
            distances = []
            for j in range(len(cluster)):
                for k in range(j + 1, len(cluster)):
                    dist = calculate_distance(
                        cluster[j].latitude, cluster[j].longitude,
                        cluster[k].latitude, cluster[k].longitude
                    )
                    distances.append(dist)
            
            avg_intra = sum(distances) / len(distances) if distances else 0
            total_intra_distance += avg_intra
            
            # í´ëŸ¬ìŠ¤í„° ì¤‘ì‹¬
            center_lat = sum(p.latitude for p in cluster) / len(cluster)
            center_lng = sum(p.longitude for p in cluster) / len(cluster)
            cluster_centers.append((center_lat, center_lng))
            
            logger.info(f"   í´ëŸ¬ìŠ¤í„° {i+1}: {len(cluster)}ê°œ ë°°ì†¡ì§€, í‰ê·  ë‚´ë¶€ ê±°ë¦¬ {avg_intra:.2f}km")
        
        # í´ëŸ¬ìŠ¤í„° ê°„ ë¶„ë¦¬ë„
        if len(cluster_centers) > 1:
            inter_distances = []
            for i in range(len(cluster_centers)):
                for j in range(i + 1, len(cluster_centers)):
                    dist = calculate_distance(
                        cluster_centers[i][0], cluster_centers[i][1],
                        cluster_centers[j][0], cluster_centers[j][1]
                    )
                    inter_distances.append(dist)
            
            avg_inter = sum(inter_distances) / len(inter_distances)
            logger.info(f"   í‰ê·  í´ëŸ¬ìŠ¤í„° ê°„ ê±°ë¦¬: {avg_inter:.2f}km")
            
            # í’ˆì§ˆ ì§€ìˆ˜ ê³„ì‚°
            if total_intra_distance > 0:
                quality_score = avg_inter / (total_intra_distance / len(clusters))
                logger.info(f"   ğŸ¯ í´ëŸ¬ìŠ¤í„° í’ˆì§ˆ ì§€ìˆ˜: {quality_score:.2f} (ë†’ì„ìˆ˜ë¡ ì¢‹ìŒ)")

def create_anti_overlap_clusters(points: List[DeliveryPoint], vehicles: List[Vehicle]) -> List[List[DeliveryPoint]]:
    """
    ì¤‘ë³µ ë°©ì§€ í´ëŸ¬ìŠ¤í„°ë§ ë©”ì¸ í•¨ìˆ˜
    
    Args:
        points: ë°°ì†¡ì§€ì  ë¦¬ìŠ¤íŠ¸
        vehicles: ì°¨ëŸ‰ ë¦¬ìŠ¤íŠ¸
        
    Returns:
        ì¤‘ë³µ ì—†ëŠ” í´ëŸ¬ìŠ¤í„°ë§ëœ ë°°ì†¡ì§€ì  ê·¸ë£¹ë“¤
    """
    if not points or not vehicles:
        logger.warning("ë°°ì†¡ì§€ì  ë˜ëŠ” ì°¨ëŸ‰ì´ ì—†ìŠµë‹ˆë‹¤.")
        return []
    
    logger.info(f"ğŸš› ì¤‘ë³µ ë°©ì§€ í´ëŸ¬ìŠ¤í„°ë§ ì‹œì‘")
    
    # ì¤‘ë³µ ë°©ì§€ í´ëŸ¬ìŠ¤í„°ë§ ì—”ì§„ ì‚¬ìš©
    engine = AntiOverlapClusteringEngine()
    clusters = engine.create_non_overlapping_clusters(points, vehicles)
    
    logger.info(f"âœ… ì¤‘ë³µ ë°©ì§€ í´ëŸ¬ìŠ¤í„°ë§ ì™„ë£Œ: {len(clusters)}ê°œ í´ëŸ¬ìŠ¤í„° ìƒì„±")
    
    return clusters 