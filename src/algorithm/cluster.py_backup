# src/algorithm/cluster.py
import numpy as np
from sklearn.cluster import KMeans, DBSCAN
import hdbscan
from typing import List, Tuple, Optional, Dict, Any
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
from datetime import datetime, timedelta
from src.model.delivery_point import DeliveryPoint
from src.model.vehicle import Vehicle, VehicleCapacity
from src.core.logger import setup_logger
from src.core.distance_matrix import DistanceMatrix
import numpy.typing as npt
from abc import ABC, abstractmethod
from scipy.spatial.distance import pdist, cdist
from sklearn.preprocessing import StandardScaler
from src.utils.distance_calculator import calculate_distance
import logging
from dataclasses import dataclass
import math
import json
import random
import copy
from src.model.time_window import TimeWindow
from src.monitoring.clustering_monitor import ClusteringMonitor

logger = logging.getLogger(__name__)
distance_matrix = DistanceMatrix()

__all__ = ['cluster_points']

@dataclass
class TimeWindow:
    """배송 가능 시간대를 나타내는 클래스"""
    start: datetime
    end: datetime

    def __init__(self, start: datetime, end: datetime):
        self.start = start
        self.end = end

    def is_valid(self, current_time: datetime) -> bool:
        """주어진 시간이 시간 윈도우 내에 있는지 확인"""
        return self.start <= current_time <= self.end

    def get_duration(self) -> float:
        """시간 윈도우의 길이를 시간 단위로 반환"""
        return (self.end - self.start).total_seconds() / 3600

class ClusteringStrategy(ABC):
    @abstractmethod
    def cluster(self, points: List[DeliveryPoint], vehicles: List[Vehicle]) -> List[List[DeliveryPoint]]:
        """포인트를 클러스터링하는 기본 메서드"""
        pass
        
    def _validate_clusters(self, clusters: List[List[DeliveryPoint]], vehicles: List[Vehicle]) -> bool:
        """모든 클러스터가 유효한지 확인"""
        if len(clusters) != len(vehicles):
            return False
            
        for cluster, vehicle in zip(clusters, vehicles):
            total_volume = sum(p.volume for p in cluster)
            total_weight = sum(p.weight for p in cluster)
            
            if total_volume > vehicle.capacity.volume or total_weight > vehicle.capacity.weight:
                return False
                
        return True
        
    def _calculate_cluster_distance(self, cluster1: List[DeliveryPoint], cluster2: List[DeliveryPoint]) -> float:
        """두 클러스터 간의 거리 계산"""
        if not cluster1 or not cluster2:
            return float('inf')
            
        center1 = np.mean([[p.latitude, p.longitude] for p in cluster1], axis=0)
        center2 = np.mean([[p.latitude, p.longitude] for p in cluster2], axis=0)
        return np.sqrt(np.sum((center1 - center2) ** 2))
        
    def _ensure_priority_distribution(self, clusters: List[List[DeliveryPoint]]) -> List[List[DeliveryPoint]]:
        """우선순위 높은 포인트를 모든 클러스터에 고르게 분배"""
        # 각 클러스터의 우선순위 포인트 수 계산
        priority_count = [sum(1 for p in cluster if p.priority > 2) for cluster in clusters]
        
        # 우선순위 포인트가 없는 클러스터 찾기
        empty_clusters = [i for i, count in enumerate(priority_count) if count == 0]
        
        if not empty_clusters:
            return clusters
            
        # 우선순위 포인트가 여러 개 있는 클러스터 찾기
        surplus_clusters = [i for i, count in enumerate(priority_count) if count > 1]
        
        # 재분배를 위한 클러스터 복사
        result_clusters = copy.deepcopy(clusters)
        
        for empty_idx in empty_clusters:
            if not surplus_clusters:
                break
                
            # 가장 많은 우선순위 포인트를 가진 클러스터 선택
            source_idx = max(surplus_clusters, key=lambda i: priority_count[i])
            
            # 이동할 우선순위 포인트 찾기
            high_priority_points = [(i, p) for i, p in enumerate(result_clusters[source_idx]) if p.priority > 2]
            
            if high_priority_points:
                idx, point = high_priority_points[0]
                # 포인트 이동
                result_clusters[source_idx].pop(idx)
                result_clusters[empty_idx].append(point)
                
                # 상태 업데이트
                priority_count[source_idx] -= 1
                priority_count[empty_idx] += 1
                
                if priority_count[source_idx] <= 1:
                    surplus_clusters.remove(source_idx)
                    
        return result_clusters
        
    def _balance_cluster_sizes(self, clusters: List[List[DeliveryPoint]], max_diff: int = 5) -> List[List[DeliveryPoint]]:
        """클러스터 크기 균형 조정"""
        result_clusters = copy.deepcopy(clusters)
        
        for _ in range(10):  # 최대 10번 시도
            sizes = [len(cluster) for cluster in result_clusters]
            size_diff = max(sizes) - min(sizes)
            
            if size_diff <= max_diff:
                break
                
            largest_idx = sizes.index(max(sizes))
            smallest_idx = sizes.index(min(sizes))
            
            # 이동할 점 찾기
            best_point_idx = -1
            min_cost = float('inf')
            
            for i, point in enumerate(result_clusters[largest_idx]):
                # 우선순위 고려: 유일한 고우선순위 포인트는 이동하지 않음
                if point.priority > 2 and sum(1 for p in result_clusters[largest_idx] if p.priority > 2) <= 1:
                    continue
                    
                # 가장 작은 클러스터와의 거리 계산
                point_coords = np.array([[point.latitude, point.longitude]])
                if result_clusters[smallest_idx]:
                    cluster_coords = np.array([[p.latitude, p.longitude] for p in result_clusters[smallest_idx]])
                    distances = cdist(point_coords, cluster_coords).min()
                else:
                    distances = 0.0
                    
                if distances < min_cost:
                    min_cost = distances
                    best_point_idx = i
            
            if best_point_idx >= 0:
                # 포인트 이동
                point = result_clusters[largest_idx].pop(best_point_idx)
                result_clusters[smallest_idx].append(point)
            else:
                # 적합한 포인트가 없으면 탈출
                break
                
        return result_clusters
        
    def _adjust_cluster_count(self, clusters: List[List[DeliveryPoint]], target_count: int, vehicles: List[Vehicle]) -> List[List[DeliveryPoint]]:
        """클러스터 수를 목표 수에 맞게 조정"""
        if len(clusters) == target_count:
            return clusters
            
        result_clusters = copy.deepcopy(clusters)
        
        if len(result_clusters) > target_count:
            # 클러스터 병합
            while len(result_clusters) > target_count:
                min_dist = float('inf')
                merge_indices = (0, 1)
                
                # 가장 가까운 두 클러스터 찾기
                for i in range(len(result_clusters)):
                    for j in range(i + 1, len(result_clusters)):
                        dist = self._calculate_cluster_distance(result_clusters[i], result_clusters[j])
                        if dist < min_dist:
                            min_dist = dist
                            merge_indices = (i, j)
                
                # 병합
                i, j = merge_indices
                result_clusters[i].extend(result_clusters[j])
                result_clusters.pop(j)
                
        elif len(result_clusters) < target_count:
            # 클러스터 분할
            while len(result_clusters) < target_count:
                # 가장 큰 클러스터 찾기
                sizes = [len(cluster) for cluster in result_clusters]
                largest_idx = sizes.index(max(sizes))
                
                if sizes[largest_idx] < 2:
                    break  # 더 이상 분할할 수 없음
                
                # K-means를 사용한 분할
                points = result_clusters[largest_idx]
                coords = np.array([[p.latitude, p.longitude] for p in points])
                
                kmeans = KMeans(n_clusters=2, random_state=42)
                labels = kmeans.fit_predict(coords)
                
                # 분할된 두 클러스터 생성
                new_clusters = [[], []]
                for idx, label in enumerate(labels):
                    new_clusters[label].append(points[idx])
                
                # 원래 클러스터 대체 및 새 클러스터 추가
                result_clusters[largest_idx] = new_clusters[0]
                result_clusters.append(new_clusters[1])
                
        return result_clusters

class EnhancedKMeansStrategy(ClusteringStrategy):
    def __init__(self):
        self._distance_cache = {}
        self._point_coords = None
        
    def cluster(self, points: List[DeliveryPoint], vehicles: List[Vehicle]) -> List[List[DeliveryPoint]]:
        """개선된 클러스터링 전략"""
        try:
            if not points or not vehicles:
                return []

            # 좌표 배열 초기화
            self._point_coords = np.array([[p.latitude, p.longitude] for p in points])
            
            # 클러스터 수 결정
            n_clusters = len(vehicles)
            
            # 초기 중심점 선택
            centers = self._initialize_centers(points, n_clusters)
            logger.info(f"초기 중심점 {len(centers)}개 선택 완료")
            
            # 클러스터 할당
            clusters = self._assign_to_clusters(points, centers, vehicles)
            logger.info(f"초기 클러스터 할당 완료: {len(clusters)}개 클러스터")
            
            # 용량 제약 조정
            clusters = self._adjust_capacity_constraints(clusters, vehicles)
            logger.info("용량 제약 조정 완료")
            
            return clusters
            
        finally:
            # 메모리 정리
            self._distance_cache.clear()
            self._point_coords = None

    def _initialize_centers(self, points: List[DeliveryPoint], n_clusters: int) -> List[DeliveryPoint]:
        """개선된 초기 중심점 선택"""
        centers = []
        remaining_points = points.copy()
        
        # 우선순위가 가장 높은 포인트를 첫 중심점으로 선택
        first_center = max(remaining_points, key=lambda p: p.priority)
        centers.append(first_center)
        remaining_points.remove(first_center)
        
        # 나머지 중심점 선택
        while len(centers) < n_clusters and remaining_points:
            # 각 남은 포인트에 대한 점수 계산
            best_point = None
            max_score = -float('inf')
            
            # 병렬 처리로 점수 계산
            with ThreadPoolExecutor(max_workers=4) as executor:
                futures = []
                for point in remaining_points:
                    futures.append(
                        executor.submit(self._calculate_center_score, point, centers)
                    )
                
                for future in futures:
                    point, score = future.result()
                    if score > max_score:
                        max_score = score
                        best_point = point
            
            if best_point:
                centers.append(best_point)
                remaining_points.remove(best_point)
            else:
                break
                
        return centers

    def _calculate_center_score(self, point: DeliveryPoint, centers: List[DeliveryPoint]) -> Tuple[DeliveryPoint, float]:
        """중심점 후보 점수 계산"""
        min_distance = float('inf')
        for center in centers:
            dist = self._get_distance(point, center)
            min_distance = min(min_distance, dist)
        
        score = min_distance * point.priority
        return point, score

    def _assign_to_clusters(self, points: List[DeliveryPoint], centers: List[DeliveryPoint], 
                          vehicles: List[Vehicle]) -> List[List[DeliveryPoint]]:
        """개선된 클러스터 할당"""
        clusters = [[] for _ in range(len(centers))]
        unassigned_points = [p for p in points if p not in centers]
        
        # 중심점들을 각 클러스터에 할당
        for i, center in enumerate(centers):
            clusters[i].append(center)
        
        # 우선순위로 정렬
        sorted_points = sorted(unassigned_points, key=lambda p: (-p.priority, p.id))
        
        # 벡터화된 거리 계산을 위한 배열
        center_coords = np.array([[c.latitude, c.longitude] for c in centers])
        
        for point in sorted_points:
            point_coord = np.array([[point.latitude, point.longitude]])
            distances = cdist(point_coord, center_coords)[0]
            
            # 각 클러스터에 대한 비용 계산
            best_cluster_idx = -1
            min_cost = float('inf')
            
            for i, (cluster, vehicle) in enumerate(zip(clusters, vehicles)):
                if not self._can_add_to_cluster(point, cluster, vehicle):
                    continue
                
                # 거리, 용량, 우선순위를 고려한 비용
                volume_ratio = sum(p.volume for p in cluster) / vehicle.capacity.volume
                weight_ratio = sum(p.weight for p in cluster) / vehicle.capacity.weight
                priority_count = sum(1 for p in cluster if p.priority > 2)
                
                cost = distances[i] * (1 + volume_ratio + weight_ratio) + priority_count
                
                if cost < min_cost:
                    min_cost = cost
                    best_cluster_idx = i
            
            if best_cluster_idx != -1:
                clusters[best_cluster_idx].append(point)
            else:
                # 가장 여유 있는 클러스터에 할당
                best_cluster_idx = self._find_most_available_cluster(clusters, vehicles)
                if best_cluster_idx is not None:
                    clusters[best_cluster_idx].append(point)
        
        return clusters

    def _get_distance(self, point1: DeliveryPoint, point2: DeliveryPoint) -> float:
        """캐시된 거리 계산"""
        cache_key = (point1.id, point2.id)
        if cache_key not in self._distance_cache:
            self._distance_cache[cache_key] = calculate_distance(
                point1.latitude, point1.longitude,
                point2.latitude, point2.longitude
            )
        return self._distance_cache[cache_key]

    def _can_add_to_cluster(self, point: DeliveryPoint, cluster: List[DeliveryPoint], 
                           vehicle: Vehicle) -> bool:
        """개선된 클러스터 용량 검사"""
        total_volume = sum(p.volume for p in cluster) + point.volume
        total_weight = sum(p.weight for p in cluster) + point.weight
        
        # 여유 공간 20% 확보
        volume_limit = vehicle.capacity.volume * 0.8
        weight_limit = vehicle.capacity.weight * 0.8
        
        return (total_volume <= volume_limit and 
                total_weight <= weight_limit)

    def _find_most_available_cluster(self, clusters: List[List[DeliveryPoint]], 
                                   vehicles: List[Vehicle]) -> Optional[int]:
        """가장 여유 있는 클러스터 찾기"""
        min_usage = float('inf')
        best_cluster = None
        
        for i, (cluster, vehicle) in enumerate(zip(clusters, vehicles)):
            total_volume = sum(p.volume for p in cluster)
            total_weight = sum(p.weight for p in cluster)
            
            volume_usage = total_volume / vehicle.capacity.volume
            weight_usage = total_weight / vehicle.capacity.weight
            max_usage = max(volume_usage, weight_usage)
            
            if max_usage < min_usage:
                min_usage = max_usage
                best_cluster = i
                
        return best_cluster

    def _adjust_capacity_constraints(self, clusters: List[List[DeliveryPoint]], 
                                  vehicles: List[Vehicle]) -> List[List[DeliveryPoint]]:
        """용량 제약 조정 로깅 추가"""
        max_iterations = 100
        iteration = 0
        
        while iteration < max_iterations:
            violations_found = False
            
            for i, (cluster, vehicle) in enumerate(zip(clusters, vehicles)):
                total_volume = sum(p.volume for p in cluster)
                total_weight = sum(p.weight for p in cluster)
                
                if (total_volume > vehicle.capacity.volume or 
                    total_weight > vehicle.capacity.weight):
                    violations_found = True
                    logger.warning(
                        f"용량 제약 위반 발견 (클러스터 {i}):\n"
                        f"- 용량: {total_volume}/{vehicle.capacity.volume} "
                        f"({total_volume/vehicle.capacity.volume*100:.1f}%)\n"
                        f"- 무게: {total_weight}/{vehicle.capacity.weight} "
                        f"({total_weight/vehicle.capacity.weight*100:.1f}%)"
                    )
                    
                    # 우선순위가 가장 낮은 포인트를 이동
                    point_to_move = min(cluster, key=lambda p: p.priority)
                    cluster.remove(point_to_move)
                    
                    # 가장 여유 있는 클러스터로 이동
                    best_cluster_idx = self._find_most_available_cluster(
                        clusters[:i] + clusters[i+1:], 
                        vehicles[:i] + vehicles[i+1:]
                    )
                    
                    if best_cluster_idx >= i:
                        best_cluster_idx += 1
                    
                    clusters[best_cluster_idx].append(point_to_move)
                    logger.info(
                        f"포인트 이동: 클러스터 {i} -> {best_cluster_idx} "
                        f"(우선순위: {point_to_move.priority})"
                    )
            
            if not violations_found:
                logger.info(f"용량 제약 조정 완료: {iteration+1}회 반복")
                break
                
            iteration += 1
            
        if iteration == max_iterations:
            logger.warning("최대 반복 횟수 도달")
            
        return clusters

class EnhancedDBSCANStrategy(ClusteringStrategy):
    def __init__(self):
        self._coords_cache = {}
        self._eps_cache = None
        self._min_samples_cache = None

    def cluster(self, points: List[DeliveryPoint], vehicles: List[Vehicle]) -> List[List[DeliveryPoint]]:
        """개선된 DBSCAN 기반 클러스터링"""
        if len(points) <= len(vehicles):
            return [[p] for p in points[:len(vehicles)]]
            
        n_clusters = len(vehicles)
        
        try:
            # 1. 특성 준비 및 정규화
            coords = self._prepare_coordinates(points)
            
            # 2. DBSCAN 파라미터 최적화
            eps, min_samples = self._optimize_parameters(coords, n_clusters)
            
            # 3. DBSCAN 클러스터링 with 예외 처리
            clusters = self._perform_dbscan(coords, points, eps, min_samples)
            
            # 4. 클러스터 수 조정 및 최적화
            clusters = self._optimize_clusters(clusters, n_clusters, vehicles)
            
            # 5. 제약 조건 검증 및 조정
            clusters = self._adjust_constraints(clusters, vehicles)
            
            return clusters
            
        except Exception as e:
            logger.error(f"DBSCAN 클러스터링 실패: {str(e)}")
            # 폴백: KMeans 전략 사용
            return EnhancedKMeansStrategy().cluster(points, vehicles)

    def _prepare_coordinates(self, points: List[DeliveryPoint]) -> np.ndarray:
        """좌표 준비 및 정규화"""
        # 캐시 확인
        cache_key = tuple(p.id for p in points)
        if cache_key in self._coords_cache:
            return self._coords_cache[cache_key]

        # 좌표 추출 및 정규화
        coords = np.array([[p.latitude, p.longitude] for p in points])
        priority_weights = np.array([[p.priority] for p in points])
        
        # 특성 결합
        features = np.hstack([coords, priority_weights])
        
        # 정규화
        scaler = StandardScaler()
        normalized_features = scaler.fit_transform(features)
        
        # 캐시 저장
        self._coords_cache[cache_key] = normalized_features
        return normalized_features

    def _optimize_parameters(self, coords: np.ndarray, n_clusters: int) -> Tuple[float, int]:
        """DBSCAN 파라미터 최적화"""
        if self._eps_cache is not None and self._min_samples_cache is not None:
            return self._eps_cache, self._min_samples_cache

        # 거리 행렬 계산
        distances = pdist(coords)
        
        # eps 값 최적화
        eps_candidates = np.percentile(distances, [15, 20, 25, 30])
        min_samples_candidates = [max(3, len(coords) // (n_clusters * x)) for x in [2, 3, 4]]
        
        best_params = None
        best_score = float('-inf')
        
        for eps in eps_candidates:
            for min_samples in min_samples_candidates:
                dbscan = DBSCAN(eps=eps, min_samples=min_samples)
                labels = dbscan.fit_predict(coords)
                
                # 클러스터링 품질 평가
                n_clusters_found = len(set(labels)) - (1 if -1 in labels else 0)
                noise_ratio = np.sum(labels == -1) / len(labels)
                
                # 점수 계산
                score = self._calculate_clustering_score(n_clusters_found, n_clusters, noise_ratio)
                
                if score > best_score:
                    best_score = score
                    best_params = (eps, min_samples)
        
        self._eps_cache = best_params[0]
        self._min_samples_cache = best_params[1]
        return best_params

    def _calculate_clustering_score(self, n_clusters_found: int, target_clusters: int, noise_ratio: float) -> float:
        """클러스터링 품질 점수 계산"""
        cluster_diff_penalty = abs(n_clusters_found - target_clusters) * 0.2
        noise_penalty = noise_ratio * 0.5
        return 1.0 - cluster_diff_penalty - noise_penalty

    def _perform_dbscan(self, coords: np.ndarray, points: List[DeliveryPoint], 
                       eps: float, min_samples: int) -> List[List[DeliveryPoint]]:
        """DBSCAN 실행 및 결과 처리"""
        dbscan = DBSCAN(eps=eps, min_samples=min_samples, n_jobs=-1)
        labels = dbscan.fit_predict(coords)
        
        # 클러스터 및 노이즈 포인트 분리
        clusters = []
        noise_points = []
        
        unique_labels = set(labels)
        for label in unique_labels:
            if label == -1:
                noise_points.extend([points[i] for i, l in enumerate(labels) if l == -1])
            else:
                cluster = [points[i] for i, l in enumerate(labels) if l == label]
                clusters.append(cluster)
        
        return self._handle_noise_points(clusters, noise_points)

    def _handle_noise_points(self, clusters: List[List[DeliveryPoint]], 
                           noise_points: List[DeliveryPoint]) -> List[List[DeliveryPoint]]:
        """노이즈 포인트 처리 개선"""
        if not noise_points:
            return clusters
        
        result_clusters = copy.deepcopy(clusters)
        remaining_points = []
        
        for point in noise_points:
            assigned = False
            distances = []
            
            # 각 클러스터와의 거리 계산
            for i, cluster in enumerate(result_clusters):
                if not cluster:
                    continue
                cluster_coords = np.array([[p.latitude, p.longitude] for p in cluster])
                point_coords = np.array([[point.latitude, point.longitude]])
                min_dist = cdist(point_coords, cluster_coords).min()
                distances.append((min_dist, i))
            
            # 거리순으로 정렬
            distances.sort()
            
            # 가장 가까운 클러스터부터 시도
            for dist, cluster_idx in distances:
                if self._can_add_to_cluster(point, result_clusters[cluster_idx]):
                    result_clusters[cluster_idx].append(point)
                    assigned = True
                    break
            
            if not assigned:
                remaining_points.append(point)
        
        # 남은 포인트들을 위한 새로운 클러스터 생성
        if remaining_points:
            result_clusters.append(remaining_points)
        
        return result_clusters

    def _optimize_clusters(self, clusters: List[List[DeliveryPoint]], 
                         target_count: int, vehicles: List[Vehicle]) -> List[List[DeliveryPoint]]:
        """클러스터 최적화"""
        # 클러스터 수 조정
        clusters = self._adjust_cluster_count(clusters, target_count, vehicles)
        
        # 우선순위 분배
        clusters = self._ensure_priority_distribution(clusters)
        
        # 크기 균형 조정
        clusters = self._balance_cluster_sizes(clusters)
        
        return clusters
    
    def _adjust_constraints(self, clusters: List[List[DeliveryPoint]], 
                          vehicles: List[Vehicle]) -> List[List[DeliveryPoint]]:
        """제약 조건 조정"""
        # 용량 제약 조정
        for i in range(3):  # 최대 3번 시도
            if self._validate_clusters(clusters, vehicles):
                break
            clusters = self._redistribute_overloaded_points(clusters, vehicles)
        
        return clusters

    def _redistribute_overloaded_points(self, clusters: List[List[DeliveryPoint]], 
                                      vehicles: List[Vehicle]) -> List[List[DeliveryPoint]]:
        """과부하 포인트 재분배"""
        result_clusters = copy.deepcopy(clusters)
        
        for i, (cluster, vehicle) in enumerate(zip(result_clusters, vehicles)):
            while not self._validate_capacity(cluster, vehicle):
                # 가장 큰 용량을 차지하는 포인트 찾기
                point_to_move = max(cluster, 
                                  key=lambda p: max(p.volume/vehicle.capacity.volume,
                                                  p.weight/vehicle.capacity.weight))
                
                # 다른 클러스터로 이동 시도
                moved = False
                for j, target_vehicle in enumerate(vehicles):
                    if i == j:
                        continue
                        
                    if self._can_add_to_cluster(point_to_move, result_clusters[j], target_vehicle):
                        cluster.remove(point_to_move)
                        result_clusters[j].append(point_to_move)
                        moved = True
                        break
                
                if not moved:
                    break
        
        return result_clusters

    def _can_add_to_cluster(self, point: DeliveryPoint, cluster: List[DeliveryPoint], 
                           vehicle: Vehicle) -> bool:
        """클러스터에 포인트를 추가할 수 있는지 확인"""
        total_volume = sum(p.volume for p in cluster) + point.volume
        total_weight = sum(p.weight for p in cluster) + point.weight
        
        # 여유 공간 20% 확보
        volume_limit = vehicle.capacity.volume * 0.8
        weight_limit = vehicle.capacity.weight * 0.8
        
        return (total_volume <= volume_limit and 
                total_weight <= weight_limit)

class HDBSCANStrategy(ClusteringStrategy):
    def __init__(self):
        self._feature_cache = {}
        self._clusterer_cache = {}
        self._prediction_cache = {}
        self.min_cluster_size_ratio = 0.1
        self.min_samples_ratio = 0.05

    def cluster(self, points: List[DeliveryPoint], vehicles: List[Vehicle]) -> List[List[DeliveryPoint]]:
        """개선된 HDBSCAN 기반 클러스터링"""
        if len(points) <= len(vehicles):
            return [[p] for p in points[:len(vehicles)]]
            
        n_clusters = len(vehicles)
        
        try:
            # 1. 특성 준비 및 전처리
            features = self._prepare_features(points)
            
            # 2. HDBSCAN 실행
            clusters = self._run_hdbscan(features, points, n_clusters)
            
            # 3. 클러스터 최적화
            clusters = self._optimize_clusters(clusters, n_clusters, vehicles)
            
            # 4. 제약 조건 검증 및 조정
            clusters = self._adjust_constraints(clusters, vehicles)
            
            # 5. 최종 검증
            if self._validate_final_clusters(clusters, vehicles):
                return clusters
            
            # 실패 시 대체 전략 사용
            logger.warning("HDBSCAN 클러스터링 실패, KMeans 전략으로 전환")
            return EnhancedKMeansStrategy().cluster(points, vehicles)
            
        except Exception as e:
            logger.error(f"HDBSCAN 클러스터링 오류: {str(e)}")
            return EnhancedKMeansStrategy().cluster(points, vehicles)

    def _prepare_features(self, points: List[DeliveryPoint]) -> np.ndarray:
        """특성 준비 및 전처리"""
        cache_key = tuple(p.id for p in points)
        if cache_key in self._feature_cache:
            return self._feature_cache[cache_key]

        # 기본 특성 추출
        coords = np.array([[p.latitude, p.longitude] for p in points])
        priorities = np.array([[p.priority] for p in points])
        volumes = np.array([[p.volume] for p in points])
        weights = np.array([[p.weight] for p in points])
        
        # 시간 윈도우 특성
        time_windows = np.array([
            [(p.time_window.end - p.time_window.start).total_seconds() / 3600]
            for p in points
        ])
        
        # 특성 결합
        features = np.hstack([
            coords,
            priorities * 2,  # 우선순위 가중치 증가
            volumes / np.max(volumes),  # 정규화
            weights / np.max(weights),  # 정규화
            time_windows / 24  # 24시간 기준 정규화
        ])
        
        # 특성 정규화
        scaler = StandardScaler()
        normalized_features = scaler.fit_transform(features)
        
        # 캐시 저장
        self._feature_cache[cache_key] = normalized_features
        return normalized_features

    def _run_hdbscan(self, features: np.ndarray, points: List[DeliveryPoint], 
                    n_clusters: int) -> List[List[DeliveryPoint]]:
        """HDBSCAN 실행 및 결과 처리"""
        # HDBSCAN 파라미터 설정
        min_cluster_size = max(5, int(len(points) * self.min_cluster_size_ratio))
        min_samples = max(3, int(min_cluster_size * self.min_samples_ratio))
        
        # HDBSCAN 실행
        clusterer = hdbscan.HDBSCAN(
            min_cluster_size=min_cluster_size,
            min_samples=min_samples,
            cluster_selection_epsilon=0.5,
            metric='euclidean',
            core_dist_n_jobs=-1,
            prediction_data=True
        )
        
        labels = clusterer.fit_predict(features)
        
        # 클러스터 및 노이즈 포인트 분리
        clusters = []
        noise_points = []
        
        for label in np.unique(labels):
            if label == -1:
                noise_points.extend([points[i] for i, l in enumerate(labels) if l == -1])
            else:
                cluster = [points[i] for i, l in enumerate(labels) if l == label]
                clusters.append(cluster)
        
        # 노이즈 포인트 처리
        return self._handle_noise_points(clusters, noise_points)

    def _handle_noise_points(self, clusters: List[List[DeliveryPoint]], 
                           noise_points: List[DeliveryPoint]) -> List[List[DeliveryPoint]]:
        """노이즈 포인트 처리 개선"""
        if not noise_points:
            return clusters
        
        result_clusters = copy.deepcopy(clusters)
        remaining_points = []
        
        for point in noise_points:
            assigned = False
            distances = []
            
            # 각 클러스터와의 거리 계산
            for i, cluster in enumerate(result_clusters):
                if not cluster:
                    continue
                cluster_coords = np.array([[p.latitude, p.longitude] for p in cluster])
                point_coords = np.array([[point.latitude, point.longitude]])
                min_dist = cdist(point_coords, cluster_coords).min()
                distances.append((min_dist, i))
            
            # 거리순으로 정렬
            distances.sort()
            
            # 가장 가까운 클러스터부터 시도
            for dist, cluster_idx in distances:
                if self._can_add_to_cluster(point, result_clusters[cluster_idx]):
                    result_clusters[cluster_idx].append(point)
                    assigned = True
                    break
            
            if not assigned:
                remaining_points.append(point)
        
        # 남은 포인트들을 위한 새로운 클러스터 생성
        if remaining_points:
            result_clusters.append(remaining_points)
        
        return result_clusters

    def _optimize_clusters(self, clusters: List[List[DeliveryPoint]], 
                         target_count: int,
                         vehicles: List[Vehicle]) -> List[List[DeliveryPoint]]:
        """클러스터 최적화"""
        # 클러스터 수 조정
        while len(clusters) > target_count:
            # 가장 작은 두 클러스터 병합
            clusters = self._merge_smallest_clusters(clusters)
            
        while len(clusters) < target_count:
            # 가장 큰 클러스터 분할
            clusters = self._split_largest_cluster(clusters)
        
        # 우선순위 분배 최적화
        clusters = self._optimize_priority_distribution(clusters)
        
        # 크기 균형 조정
        clusters = self._balance_cluster_sizes(clusters)
        
        return clusters

    def _merge_smallest_clusters(self, clusters: List[List[DeliveryPoint]]) -> List[List[DeliveryPoint]]:
        """가장 작은 클러스터들 병합"""
        if len(clusters) <= 1:
            return clusters
            
        # 클러스터 크기 기준 정렬
        sizes = [(len(cluster), i) for i, cluster in enumerate(clusters)]
        sizes.sort()
        
        # 가장 작은 두 클러스터 선택
        smallest1_idx = sizes[0][1]
        smallest2_idx = sizes[1][1]
        
        # 병합
        merged = clusters[smallest1_idx] + clusters[smallest2_idx]
        new_clusters = [c for i, c in enumerate(clusters) 
                       if i not in [smallest1_idx, smallest2_idx]]
        new_clusters.append(merged)
        
        return new_clusters

    def _split_largest_cluster(self, clusters: List[List[DeliveryPoint]]) -> List[List[DeliveryPoint]]:
        """가장 큰 클러스터 분할"""
        if not clusters:
            return clusters
            
            # 가장 큰 클러스터 찾기
        largest_idx = max(range(len(clusters)), key=lambda i: len(clusters[i]))
        largest_cluster = clusters[largest_idx]
        
        if len(largest_cluster) < 2:
            return clusters
            
            # K-means로 분할
            coords = np.array([[p.latitude, p.longitude] for p in largest_cluster])
            kmeans = KMeans(n_clusters=2, random_state=42)
            labels = kmeans.fit_predict(coords)
            
            # 새 클러스터 생성
            cluster1 = [p for p, label in zip(largest_cluster, labels) if label == 0]
            cluster2 = [p for p, label in zip(largest_cluster, labels) if label == 1]
            
            # 결과 병합
            new_clusters = [c for i, c in enumerate(clusters) if i != largest_idx]
            new_clusters.extend([cluster1, cluster2])
            
            return new_clusters

    def _validate_final_clusters(self, clusters: List[List[DeliveryPoint]], 
                               vehicles: List[Vehicle]) -> bool:
        """최종 클러스터 검증"""
        if not self._validate_clusters(clusters, vehicles):
            return False
            
        # 추가 검증
        for cluster, vehicle in zip(clusters, vehicles):
            # 시간 윈도우 검증
            time_span = self._calculate_time_span(cluster)
            if time_span > 8:  # 8시간 초과
                return False
                
            # 우선순위 분포 검증
            if not self._validate_priority_distribution(cluster):
                return False
        
        return True

    def _calculate_time_span(self, cluster: List[DeliveryPoint]) -> float:
        """클러스터의 시간 범위 계산"""
        if not cluster:
            return 0.0
            
        start_times = [p.time_window.start for p in cluster]
        end_times = [p.time_window.end for p in cluster]
        
        time_span = (max(end_times) - min(start_times)).total_seconds() / 3600
        return time_span

    def _validate_priority_distribution(self, cluster: List[DeliveryPoint]) -> bool:
        """우선순위 분포 검증"""
        if not cluster:
            return True
            
        priority_counts = {1: 0, 2: 0, 3: 0}
        for point in cluster:
            priority_counts[point.priority] += 1
            
        # 우선순위 3인 포인트가 너무 많지 않은지 확인
        high_priority_ratio = priority_counts[3] / len(cluster)
        return high_priority_ratio <= 0.4  # 최대 40%까지 허용

monitor = ClusteringMonitor()

@monitor.monitor("enhanced_kmeans")
def cluster_points(points: List[DeliveryPoint], vehicles: List[Vehicle], 
                  strategy: str = 'enhanced_kmeans') -> Optional[List[List[DeliveryPoint]]]:
    if not points or not vehicles:
        return None
        
    available_vehicles = _filter_suitable_vehicles(points, vehicles)
    if not available_vehicles:
        return None
        
    # 최적 클러스터 수 결정
    n_clusters = _determine_optimal_cluster_count(points, available_vehicles)
    
    strategies = {
        'enhanced_kmeans': EnhancedKMeansStrategy(),
        'enhanced_dbscan': EnhancedDBSCANStrategy(),
        'hdbscan': HDBSCANStrategy()
    }
    
    clustering_strategy = strategies.get(strategy, EnhancedKMeansStrategy())
    return clustering_strategy.cluster(points, available_vehicles[:n_clusters])

def _filter_suitable_vehicles(points: List[DeliveryPoint], vehicles: List[Vehicle]) -> List[Vehicle]:
    """포인트 특성에 맞는 차량만 필터링"""
    suitable_vehicles = []
    for vehicle in vehicles:
        # 차량의 기본 요구사항만 확인
        if _check_basic_vehicle_requirements(vehicle):
            suitable_vehicles.append(vehicle)
    return suitable_vehicles

def _check_basic_vehicle_requirements(vehicle: Vehicle) -> bool:
    """차량의 기본 요구사항 확인"""
    # 기본적인 운영 가능 여부만 체크
    return (vehicle.capacity.volume > 0 and 
            vehicle.capacity.weight > 0 and 
            'STANDARD' in vehicle.features)

def _determine_optimal_cluster_count(points: List[DeliveryPoint], vehicles: List[Vehicle]) -> int:
    """최적의 클러스터 수 결정"""
    # 요청된 차량 수를 우선적으로 사용
    requested_clusters = len(vehicles)
    
    # 포인트 특성 분석
    total_volume = sum(p.volume for p in points)
    total_weight = sum(p.weight for p in points)
    priority_points = sum(1 for p in points if p.priority > 2)
    
    # 차량 용량 분석
    avg_vehicle_volume = sum(v.capacity.volume for v in vehicles) / len(vehicles)
    avg_vehicle_weight = sum(v.capacity.weight for v in vehicles) / len(vehicles)
    
    # 필요한 최소 차량 수 계산
    min_vehicles_by_volume = math.ceil(total_volume / (avg_vehicle_volume * 0.95))  # 95% 용량 제한
    min_vehicles_by_weight = math.ceil(total_weight / (avg_vehicle_weight * 0.95))
    min_vehicles_by_priority = math.ceil(priority_points / 2)
    
    # 최소 필요 클러스터 수
    min_required = max(
        min_vehicles_by_volume,
        min_vehicles_by_weight,
        min_vehicles_by_priority,
        1  # 최소 1개
    )
    
    # 요청된 클러스터 수와 실제 필요한 수 중 큰 값 사용
    return min(max(requested_clusters, min_required), len(points))

def calculate_cluster_metrics(cluster: List[DeliveryPoint]) -> Dict:
    """클러스터의 메트릭 계산"""
    total_volume = sum(point.volume for point in cluster)
    total_weight = sum(point.weight for point in cluster)
    total_priority = sum(point.get_priority_weight() for point in cluster)
    
    # 시간 윈도우 범위 계산
    time_windows = [(p.time_window[0], p.time_window[1]) for p in cluster]
    earliest = min(tw[0] for tw in time_windows)
    latest = max(tw[1] for tw in time_windows)
    time_span = (latest - earliest).total_seconds() / 3600  # 시간 단위
    
    return {
        'volume': total_volume,
        'weight': total_weight,
        'priority': total_priority,
        'time_span': time_span,
        'size': len(cluster)
    }

def balance_clusters(
    clusters: List[List[DeliveryPoint]],
    vehicles: List[Vehicle]
) -> List[List[DeliveryPoint]]:
    """개선된 클러스터 밸런싱"""
    if not clusters or not vehicles:
        return clusters

    logger.info("클러스터 밸런싱 시작")
    max_iterations = 100
    iteration = 0
    balanced = False

    try:
        # 클러스터 메트릭 계산
        with ProcessPoolExecutor() as executor:
            cluster_metrics = list(executor.map(calculate_cluster_metrics, clusters))
        
        while not balanced and iteration < max_iterations:
            balanced = True
            iteration += 1
            
            for i, (cluster, vehicle) in enumerate(zip(clusters, vehicles)):
                metrics = cluster_metrics[i]
                
                # 용량 또는 시간 제약 위반 확인
                if (metrics['volume'] > vehicle.capacity.volume or
                    metrics['weight'] > vehicle.capacity.weight or
                    metrics['time_span'] > 8):  # 8시간 제한
                    
                    # 이동할 포인트 선택
                    move_candidates = []
                    for point in cluster:
                        # 다른 클러스터로 이동 가능성 검사
                        for j, (target_cluster, target_vehicle) in enumerate(zip(clusters, vehicles)):
                            if i == j:
                                continue
                                
                            target_metrics = cluster_metrics[j]
                            
                            # 이동 가능성 검사
                            if (target_metrics['volume'] + point.volume <= target_vehicle.capacity.volume and
                                target_metrics['weight'] + point.weight <= target_vehicle.capacity.weight):
                                
                                # 이동 비용 계산
                                cost = _calculate_move_cost(point, cluster, target_cluster)
                                move_candidates.append((point, j, cost))
                    
                    if move_candidates:
                        # 가장 비용이 낮은 이동 선택
                        point, target_idx, _ = min(move_candidates, key=lambda x: x[2])
                        
                        # 포인트 이동
                        clusters[i].remove(point)
                        clusters[target_idx].append(point)
                    
                    # 메트릭 업데이트
                        cluster_metrics[i] = calculate_cluster_metrics(clusters[i])
                        cluster_metrics[target_idx] = calculate_cluster_metrics(clusters[target_idx])
                        
                        balanced = False
        
    except Exception as e:
        logger.error(f"클러스터 밸런싱 중 오류 발생: {str(e)}")
        return clusters

    return clusters

def _calculate_move_cost(
    point: DeliveryPoint,
    source_cluster: List[DeliveryPoint],
    target_cluster: List[DeliveryPoint]
) -> float:
    """포인트 이동 비용 계산"""
    if not target_cluster:
        return float('inf')
    
    # 거리 기반 비용
    target_center = np.mean([[p.latitude, p.longitude] for p in target_cluster], axis=0)
    distance_cost = np.sqrt(
        (point.latitude - target_center[0])**2 +
        (point.longitude - target_center[1])**2
    )
    
    # 시간 윈도우 기반 비용
    target_times = [p.time_window for p in target_cluster]
    target_start = min(tw[0] for tw in target_times)
    target_end = max(tw[1] for tw in target_times)
    time_compatibility = (
        1 if target_start <= point.time_window[0] <= target_end and
           target_start <= point.time_window[1] <= target_end
        else 2
    )
    
    # 우선순위 기반 비용
    priority_diff = abs(
        np.mean([p.priority for p in target_cluster]) -
        point.priority
    )
    
    return distance_cost * time_compatibility * (1 + priority_diff * 0.1)